{
  "_id": "_design/api",
  "language": "javascript",
  "views": {
    "trash_by_root": {
      "map": "// Index trashed entities by their trash root\nfunction(doc) {\n    if(doc.trash_info) {\n        emit(doc.trash_info.trash_root, null);\n    }\n}\n"
    },
    "root_sources": {
      "map": "function(doc) {\n    if(doc.type === 'Source' && doc.attributes.is_root) {\n        emit(doc._id, null);\n    }\n}\n"
    },
    "experiment_entities": {
      "map": "/* Map function for experiment -> all contained entities */\nfunction(doc) {\n    if(doc.links && doc.links.experiments) {\n        for(var i = 0; i < doc.links.experiments.length; i++) {\n            emit( doc.links.experiments[i], null );\n        }\n    }\n}\n"
    },
    "entities_for_tag": {
      "map": "function(doc) {\n    if (doc.annotation_type === 'keywords') {\n        emit ([doc.annotation.tag, doc.user], { \"_id\" :  doc.entity_id });\n    }\n}\n"
    },
    "sources_by_identifier": {
      "map": "function(doc) {\n    if(doc.type === 'Source') {\n        emit(doc.attributes.identifier, null);\n    }\n}\n"
    },
    "links": {
      "map": {{links.js}}
    },
    "entities_for_device_parameter": {
      "map": "function(doc) {\n     if(doc.attributes && doc.attributes.device_parameters) {\n         for(var key in doc.attributes.device_parameters) {\n            if( doc.attributes.device_parameters.hasOwnProperty(key) ) {\n                var value = doc.attributes.device_parameters[key];\n                emit([key, value], doc._id);\n             }\n         }\n     }\n}\n"
    },
    "users_by_name": {
      "map": "function(doc) { if(doc.type==='User' && doc.attributes && doc.attributes.name) {    emit(doc.username, null); } }\n"
    },
    "users_by_email": {
      "map": "function(doc) { if(doc.type==='User' && doc.attributes && doc.attributes.email) {    emit(doc.attributes.email.toLowerCase(), null); } }\n"
    },
    "annotation_docs": {
      "map": {{annotation_docs.js}}
    },
    "entities_by_type": {
      "map": "/*\nView mapping function to collate entities by type\n*/\nfunction(doc) {\n    if(doc.type) {\n        emit(doc.type, null);\n    }\n}\n",
      "reduce": "_count"
    },
    "entities_for_protocol_parameter": {
      "map": "/*\nMap function for document protocol parameters\n*/\n\nfunction(doc) {\n     if(doc.attributes && doc.attributes.protocol_parameters) {\n         for(var key in doc.attributes.protocol_parameters) {\n            if( doc.attributes.protocol_parameters.hasOwnProperty(key) ) {\n                var value = doc.attributes.protocol_parameters[key];\n                emit([key, value], doc._id);\n             }\n         }\n     }\n }\n"
    },
    "sources_by_label_and_identifier": {
      "map": "function(doc) {\n    if(doc.type === 'Source') {\n        emit([doc.attributes.label,doc.attributes.identifier], null);\n    }\n}\n"
    },
    "entities_for_property": {
      "map": "function(doc) {\n    if (doc.annotation_type && doc.annotation_type === 'properties') {\n        emit ([doc.annotation.key, doc.annotation.value, doc.user], { \"_id\" :  doc.entity_id });\n    }\n}\n"
    },
    "head_revs": {
      "map": "function(doc) {\n    if(doc.type === 'Revision' && doc.attributes.head && doc.attributes.resource) {\n        emit(doc.attributes.resource, null);\n    }\n}\n"
    },
    "all": {
      "map": "function(doc) { if (doc.type) emit( doc._id, null ) } "
    },
    "trash_roots_by_user": {
      "map": "// Trash roots by user\nfunction(doc) {\n    if(doc.trash_info && doc.trash_info.trash_root === \"ovation://entities/\" + doc._id) {\n\n        var trash_root_uri = doc.trash_info.trash_root;\n\n        // split ovation://entities/id by \"/\" and remove empty strings\n        var comps = trash_root_uri.split(\"/\").filter(function(s) { return s; });\n\n        // we want the last string\n        var trash_root_id = comps[comps.length -1];\n\n        emit(doc.trash_info.trashing_user, {_id : trash_root_id});\n    }\n}\n"
    }
  }
}
